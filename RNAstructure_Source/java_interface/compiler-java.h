# Include a file that contains system-specific configuration. This file can be auto-generated by invoking `make javaconfig`
JAVA_CONFIG_FILE=java-config.make
-include $(JAVA_CONFIG_FILE)
###################### Java-specific options ############################################
# These variables are required for compilation of java gui and for 
#   linking of the native library that interfaces with Java
CXXFLAGS+=-D_JAVA_GUI

# Uncomment below to enable multithreading in the Java RNA library (changes to the src/rank*.cpp files are necessary before SMP can be used)
# ifneq ($(OPSYSTEM),Mac)
#   # When compiling the RNAstructure_GUI library, use OpenMP (SMP) and pThreads, but only if using Linux or Windows (Not Mac)
#   CXXFLAGS+=$(CXXOPENMPFLAGS) -pthread
# endif

# set java compiler and jar-archiver (usually included in the PATH, except possibly on Windows)
JXX ?= javac
JAR ?= jar

# JXXFLAGS - Java compiler flags
#            Require java version >=1.7.0 (and require that the source code is compatible with v1.7.0)
JXXFLAGS = -source 7 -target 7 -encoding UTF-8 -Xlint:-options 

# JAVA_HOME - modern installations of Java typically have the binary commands (e.g. javac) 
#   as well as the JNI header files (e.g. jni.h) all housed under a single parent directory,
#   which is *sometimes* specified in the environement variable JAVA_HOME.
#   In this scheme, the binary commands are located in $JAVA_HOME/bin and the headers
#   are in $JAVA_HOME/include  and   $JAVA_HOME/include/$JNI_OS_NAME
#   where JNI_OS_NAME is a variable defined in this file that depends on the operating
#   system (e.g. "darwin" on Mac, "linux" on GNU/Linux, and "win32" on Microsoft Windows)
#   In addition to the JAVA_HOME location, the binaries and/or headers can be found
#   in other locations--usually via symlinks to the files under JAVA_HOME.
#
#   Thus, if JAVA_HOME has been defined or can be determined by searching etc, then the 
#   paths to the binary files and header files can usually be determined from it.
# Enter the PATH to JAVA_HOME below. Otherwise it will be auto-detected later. 
JAVA_HOME ?= 
# JDK_BIN -- The path to the JDK binary commands (e.g. javac, jar etc) This variable can 
#   usually be left alone, as long as the typical java installation has been performed. 
JDK_BIN   ?= $(JAVA_HOME)/bin

###################### JNI-specific flags: ############################################
# ('JNI' stands for Java Native Interface. It is the 'glue' that connects
# the Java Runtime with 'native' libraries, such as the RNAstructure class library.)
# JNI_CXXFLAGS - Additional flags that must be passed to the C++ compiler (not javac) when
#    compiling the JNI *.cxx source files (which are generated by SWIG).
JNI_CXXFLAGS = -D_JAVA_GUI $(JNI_INCLUDE_FLAGS) -O ### (This is usually different for Mac, so it is redefined below.)

# COMPILE_JNI  - The default recipe to compile the c++ files (.cpp and .cxx) 
#    required for the Java native library.
COMPILE_JNI  = ${COMPILE_CPP} ${JNI_CXXFLAGS}

# LINK_JNI_LIB - rule for linking object files to make the shared library that interfaces with Java. 
LINK_JNI_LIB = ${LINK} ${JNI_CXXFLAGS} ${LIBFLAGS}  ### Required object files will be appended here.

# JDK_INCLUDE - The path to the Java JDK headers (including headers for JNI). 
#    This can be be specified here or as an environment variable or on the 
#    command-line. If not set, the makefile will try to Auto-detect location 
#    of JNI headers. ** NOTE: If JDK-autodetection fails or points to a 
#    different JDK than desired, set the JDK_INCLUDE variable as noted above.
#    The directory differs between operating systems, so it is set in 
#    the OS-specific section below. See the section called "About JDK_INCLUDE" 
#    for details.
# JNI_INCLUDE_FLAGS - Flags specifying the folders to include for 
#    JNI compilation (e.g. -I<directory>). Specifying them separately from 
#    JNI_CXXFLAGS allows better portability between operating systems.
JDK_INCLUDE ?= $(JAVA_HOME)/include
JNI_INCLUDE_FLAGS=-I${JDK_INCLUDE} -I${JDK_INCLUDE}/$(JNI_OS_NAME) ##  See the section called "About JNI_INCLUDE_FLAGS" for details.

# Some macros for finding files or commands, with the ultimate goal of resolving or finding the JAVA_HOME variable (or a sub-folder: JDK_INCLUDE or JDK_BIN)
# (Note that the only really important commands are RESOLVE_JAVA_HOME and FIND_JAVA_HOME, but for readability and maintainablility, those macros have been broken down into several helper macros, which are listed below.)
GET_FILE_DATES=$(sort $(foreach FILE_PATH,$1,$(shell $(CMD_DATE_AND_PATH) $(FILE_PATH))))#                  Usage: $(call GET_FILE_DATES, $(files)) -- Returns each file with the last-modified date prepended to its path (separated by "___")  $(call GET_FILE_DATES, /home/user/hello.txt /var/etc/world.txt  ) ==> 1420475592___/home/user/hello.txt  1443456736___/var/etc/world.txt 
CMD_DATE_AND_PATH=stat -c '%Y___%n'#                                                                        Defines a command to get the date of a file and prepend it to the file path. i.e.: DATE___PATH.  This particular command works on GNU/Linux and Windows, but NOT on (BSD-derived) Mac OSX. (See the MAC-specific section below)
STRIP_DATES=$(foreach FILE_SPEC,$1,$(lastword $(subst ___, ,$(FILE_SPEC))))#                                Usage: $(call STRIP_DATES, $(filespecs)) -- Removes the date prepended to each file-spec and returns just the file paths. (i.e. the reverse of GET_FILE_DATES)
GET_MOST_RECENT_FILE=$(call STRIP_DATES,$(lastword $(call GET_FILE_DATES,$1)))#                             Usage: $(call GET_MOST_RECENT_FILE, $(files)) -- Returns the most recently modified file from the list. It does this by using `stat` to prepend the modified date onto the front of each path, then sorting them (so more recent files appear later in the list), then it selects the last file (i.e. most recent), and removes the date.
FIND_COMMAND=$(call GET_MOST_RECENT_FILE,$(foreach CMD_FILE_PATH,$1,$(shell command -v $CMD_FILE_PATH)))#   Usage: $(call FIND_COMMAND, $(commands)) -- uses `command -v` to resolve command-names into valid paths. Then returns the most recent executable file in the list of resulting commands.
FIND_FILES=$(shell find $1 -name $2 -print 2>/dev/null)#                                                    Usage: $(call FIND_FILES, $(dirs), $(filename)) -- uses `find` to get a list of all files matching the specified $(filename) under any and all of the directories listed in $(dirs)
FIND_NAMED_FILE=$(call GET_MOST_RECENT_FILE,$(call FIND_FILES,$1,$2))#                                      Usage: $(call FIND_NAMED_FILE, $(dirs), $(filename)) -- Calls the function FIND_FILES and returns the most recent file from the list of results.
FIND_JDK_INCLUDE=$(realpath $(dir $(call FIND_NAMED_FILE,$1,jni.h)))#                                       Usage: $(call FIND_JDK_INCLUDE, $(dirs)) -- Given a list of potential starting drectories, this attempts to find the sub-directory containing the most recent jni.h header file.
FIND_JDK_BIN=$(realpath $(dir $(call FIND_NAMED_FILE,$1,javac -o -name javac.exe)))#                        Usage: $(call FIND_JDK_BIN, $(dirs)) -- Given a list of potential commands or exectables (e.g. javac,  /usr/bin/javac etc), this attempts to find the most recent existing exectable file from the list of results, and then return its parent directory.
RESOLVE_JAVAC=$(strip $(if $(JAVAC),$(JAVAC),$(realpath $(shell command -v javac))))#                       A macro intended to be a 'fast' way to get the full path to `javac` (most likely it only works when javac is in the PATH, e.g. on linux or Mac, but not as often on Windows)
FIND_JAVA_HOME=$(realpath $(call FIND_JDK_INCLUDE,$(JAVA_HOME_SEARCH_DIRS))/../)#                           A macro intended to search for JAVA_HOME within any of the directories specifed in the variable $(JAVA_HOME_SEARCH_DIRS)
# Additional commands specified in the OS-Specific section:
#   RESOLVE_JAVA_HOME - a 'fast' command for finding the path to JAVA_HOME  (whearas FIND_JAVA_HOME, listed above, is usually a 'slower', but potentially more robust command for finding the path to JAVA_HOME)
#   JAVA_HOME_SEARCH_DIRS - a list of directories to search for JAVA_HOME (if RESOLVE_JAVA_HOME fails)
#   CMD_DATE_AND_PATH - command that should print file information in the format {DATE}___{FULLPATH} where {DATE} is a *sortable* representation of modification date.


############## Operating-System-Specific Configuration ######################
ifeq (${OPSYSTEM},Linux)
  ############# LINUX #############
  # LINK_JNI_LIB is fine as defined above.
  RESOLVE_JAVA_HOME=$(realpath $(dir $(RESOLVE_JAVAC))../)#       This macro works by simply obtaining the symlink-resolved path to javac and assuming that it is in JAVA_HOME/bin 
  JAVA_HOME_SEARCH_DIRS=/usr/lib/jvm
  JNI_OS_NAME=linux
else ifeq (${OPSYSTEM},Mac)
  ############# MAC ###############
  LINK_JNI_LIB += -framework JavaVM  # Required object files will be appended here.
  RESOLVE_JAVA_HOME=$(shell $(dir $(RESOLVE_JAVAC))/java_home)#  This macro resolves symlinks to find the true location of javac. Then it runs the executable `java_home` from the same directory. This outputs the path to the JAVA_HOME directory. It appears to only be avialble on MAC
  JAVA_HOME_SEARCH_DIRS=/Library/Java/JavaVirtualMachines/*/Contents/Home
  JNI_OS_NAME=darwin
  CMD_DATE_AND_PATH=stat -f '%m___%N'# Print file information in the format {DATE}___{FULLPATH}
else ifeq (${OPSYSTEM},Windows) 
  ############# WINDOWS ###########
  LINK_JNI_LIB += -Wl,--add-stdcall-alias # Required object files will be appended here.
  ##  See the section called "About JNI_INCLUDE_FLAGS" for details.
  JNI_OS_NAME=win32
  JAVA_HOME_SEARCH_DIRS=$(SYSROOT)/Progra~1/Java $(SYSROOT)/Progra~2/Java

  # This macro queries the Windows registry to get the current JDK version. A second query, 
  #   using this version number, retrieves the location of JAVA_HOME from the Windows registry.
  # Unfotunately the path is returned in the form "C:\Program Files\..." which is NOT usuable by 
  #   make (because done of the make functions support spaces in path names, except wildcard and 
  #   it only supports *escaped* spaces)
  # So the function then has to replace C:\Program Files... with either $(SYSROOT)/Progra~1 or $(SYSROOT)/Progra~2, whichever is appropriate.
  PF_W=$(PROGRAMFILES)
  PF86_W=$(shell printenv 'ProgramFiles(x86)')
  PF=$(SYSROOT)/Progra~1
  PF86=$(SYSROOT)/Progra~2
  REPLACE_PF=$(subst \,/,$(subst $(PF_W),$(PF),$(subst $(PF86_W),$(PF86),$1)))
  RESOLVE_JAVA_HOME=$(call REPLACE_PF,$(shell \
  	REG_KEY='HKLM\SOFTWARE\JavaSoft\Java Development Kit'; \
    function getRegVal { shopt -s extglob;local var=$$(reg query "$$1" -v "$$2"  2>/dev/null);echo "$${var$h$h*REG_SZ*([[:space:]])}";}; \
    JVER=$$(getRegVal "$$REG_KEY" CurrentVersion); \
    JAVA_HOME=$$(getRegVal "$$REG_KEY\\$$JVER" JavaHome); \
    echo "$$JAVA_HOME";))
  # The RESOLVE_JAVA_HOME macro below works by using wildcard to find all the paths of the form "C:\Program Files\Java\*\include\jni.h"
  # the folders matching the * wildcard represent JAVA_HOME. (This wildcard search is actually applied to all dirs in JAVA_HOME_SEARCH_DIRS, so both 32-bit and 64-bit program files are checked)
  RESOLVE_JAVA_HOME_ALT=$(realpath $(dir $(call GET_MOST_RECENT_FILE,$(foreach DIR_PATH,$(JAVA_HOME_SEARCH_DIRS),$(DIR_PATH)/*/include/jni.h)))../)
endif

# Debugging...
# V:=$(JAVA_HOME_SEARCH_DIRS)
# $(info JAVA_HOME_SEARCH_DIRS=$V)
# V:=$(call FIND_FILES,$V,jni.h)
# $(info FIND_FILES=$V)
# V:=$(call GET_FILE_DATES,$V)
# $(info GET_FILE_DATES=$V)
# V:=$(call STRIP_DATES,$(lastword $V))
# $(info lasword,STRIP_DATES=$V)
# $(info FIND_NAMED_FILE=$(call FIND_NAMED_FILE,$(JAVA_HOME_SEARCH_DIRS),jni.h))
# V:=$(realpath $(dir $V)
# $(info realpath,dir=$V)
# $(info $(call FIND_JDK_INCLUDE,$(JAVA_HOME_SEARCH_DIRS))

# $(info FIND_JAVA_HOME=$(FIND_JAVA_HOME))
# $(info FIND_JDK_INCLUDE=$(call FIND_JDK_INCLUDE,$(JAVA_HOME_SEARCH_DIRS)))
# $(info JavaDir=$(wildcard $(SYSROOT)/Progra~1/Java))
# $(info FIND_NAMED_FILE=$(call FIND_NAMED_FILE, $(SYSROOT)/Progra~1/Java,jni.h))
# $(info GET_MOST_RECENT_FILE=$(call GET_MOST_RECENT_FILE, /c/Progra~1/Java/jdk1.8.0_25/include/jni.h /c/Progra~1/Java/jdk1.8.0_45/include/jni.h))
# $(info FILE_PATHS=$(foreach FILE_PATH,/c/Progra~1/Java/jdk1.8.0_25/include/jni.h /c/Progra~1/Java/jdk1.8.0_45/include/jni.h,$(shell $(CMD_DATE_AND_PATH) $(FILE_PATH))))

######## Verifications ###############
  # These ae just being listed here (NOT run immediately)
  FOUND_JAVA_HOME=$(wildcard $(JAVA_HOME)/include/jni.h)
  FOUND_JDK_INCLUDE= $(wildcard $(JDK_INCLUDE)/jni.h)
  FOUND_JDK_INCLUDE2=$(wildcard $(JDK_INCLUDE)/$(JNI_OS_NAME)/jni_md.h)
  FOUND_JDK_BIN=$(wildcard $(JDK_BIN)/javac $(JDK_BIN)/javac.exe)
  FOUND_JXX=$(shell command -v $(JXX))
  FOUND_JAR=$(shell command -v $(JAR))

# Get the list of all 'goals' passed to make. e.g. make "GUI" etc. If there are no goals (i.e. just "make"), use the term "default"
GOALS:=$(or $(MAKECMDGOALS),default)
#SKIP_RESOLVE -- A list of goals that DO NOT require resolution or verification of of paths (like JAVA_HOME, JXX etc)
SKIP_RESOLVE:=help instructions clean realclean default
#SKIP_VERIFY -- A list of goals that DO NOT require verification of paths (like JAVA_HOME, JXX etc), but do require simple resolution
SKIP_VERIFY:=$(SKIP_RESOLVE) javaconfig 
# Get the list of all goals that DO require path resolution.
MUST_RESOLVE:=$(filter-out $(SKIP_RESOLVE),$(GOALS))
# Get the list of all goals that DO require verification.
MUST_VERIFY:=$(filter-out $(SKIP_VERIFY),$(GOALS))
# If the user has specified "javaconfig" as a goal, set the following flag
DO_CONFIG:=$(filter javaconfig,$(GOALS))

# PATH RESOLUTION -- attempt to perform simple/fast resolution of some important paths (JAVA_HOME, JXX). 
# Under most circumstances, this is enough to auto-detect these paths, so the user does not have to do any
# manual configuration.
# But DO NOT perform these additional steps if we are only doing 'make clean' or 'make help' etc (hence the test for goals in the 'MUST_RESOLVE' category)
ifneq ($(strip $(MUST_RESOLVE)),)
  $(info Resolving Java Configuration...)
  ifeq ($(FOUND_JAVA_HOME),)
    # if JAVA_HOME was not set above, use the 'fast' method of resolving it
    JAVA_HOME:=$(strip $(RESOLVE_JAVA_HOME))
    $(info JAVA_HOME=$(JAVA_HOME))
    ifeq ($(FOUND_JAVA_HOME),)
      JAVA_HOME:=$(strip $(RESOLVE_JAVA_HOME_ALT))
      $(info JAVA_HOME_2=$(JAVA_HOME))
    endif
  endif

  # if javac and/or jar are STILL not set (or found using command -v) then set to JAVA_HOME/bin/javac
  ifeq ($(FOUND_JXX),)
    #Try this alternate first, before showing error
    JXX=$(JAVA_HOME)/bin/javac
    JAR=$(JAVA_HOME)/bin/jar
  endif
  $(info Configuration Complete.)
endif

# Run verification of folder and command configuration (e.g. JXX, JDK_INCLUDE).
# SKIP this if the goal is one of those in SKIP_VERIFY_GOALS (e.g. 'clean' or 'help' etc)
ifneq ($(strip $(MUST_VERIFY)),)
  $(info Verifying Java Configuration...)
  JAVA_HOME_MSG=(Please consider running 'make javaconfig' to perform automatic configuration. Alternatively, manually setting the JAVA_HOME environment variable could help resolve this issue.) 

  ifeq ($(FOUND_JAVA_HOME),)#Still not found!!
    #Just show a warning because JAVA_HOME is not necessary (as long as JDK_INCLUDE and either JDK_BIN or JXX have been set)
    $(warning The JAVA_HOME environment variable was not defined or could not be located. $(JAVA_HOME_MSG)$n)
  endif

  ifeq ($(FOUND_JDK_BIN)),)
    #Just show a warning because JDK_BIN is not necessary (as long as JAR and JXX have been set)
    $(warning  The Java JDK 'bin' directory could not be located. $(JAVA_HOME_MSG)$n)
  endif

  ifeq ($(strip $(FOUND_JXX)),)
    $(error The Java Compiler was not defined or could not be located. $(JAVA_HOME_MSG)$n)
  endif

  ifeq ($(strip $(FOUND_JAR)),)
    $(error The Java Jar program could not be located.  $(JAVA_HOME_MSG)$n)
  endif

  ifeq ($(strip $(FOUND_JDK_INCLUDE)),)
    $(error The Java JDK header file 'jni.h' could not be located.$n$t--JDK_INCLUDE: $(JDK_INCLUDE).$n$t--$(JAVA_HOME_MSG)$n)
  endif

  ifeq ($(strip $(FOUND_JDK_INCLUDE2)),)
    $(error The Java JDK header file 'jni_md.h' could not be located.$n$t--JDK_INCLUDE_OS: $(JDK_INCLUDE)/$(JNI_OS_NAME).$n$t--$(JAVA_HOME_MSG)$n))
  endif

  $(info Verification Complete.)
endif

# Perform the following operations ONLY if the user is running 'make javaconfig'
ifeq ($(filter javaconfig,$(GOALS)),javaconfig)
  FAILED_MSG=(Please consider setting the JAVA_HOME or JDK_BIN environment variables manually.)
  $(info Makefile Java Auto-Config)
  ifeq ($(FOUND_JAVA_HOME),)
    $(info Searching for JAVA_HOME...)
    JAVA_HOME:=$(FIND_JAVA_HOME)
    $(info JAVA_HOME: $(if $(FOUND_JAVA_HOME),$(JAVA_HOME),Not Found. $(FAILED_MSG)$n))
  endif

  ifeq ($(FOUND_JDK_INCLUDE),)
    JDK_INCLUDE=$(JAVA_HOME)/include
    ifeq ($(FOUND_JDK_INCLUDE),)
      $(info Searching for JDK_INCLUDE...)
      JDK_INCLUDE:=$(FIND_JDK_INCLUDE)
      $(info JDK_INCLUDE: $(if $(FOUND_JDK_INCLUDE),$(JDK_INCLUDE),Not Found. $(FAILED_MSG)$n))
    endif
  endif

  ifeq ($(FOUND_JDK_BIN),)
    JDK_BIN=$(JAVA_HOME)/bin
    ifeq ($(FOUND_JDK_BIN),)
      $(info Searching for JDK_BIN...)
      JDK_BIN:=$(FIND_JDK_BIN)
      $(info JDK_BIN: $(if $(FOUND_JDK_BIN),$(JDK_BIN),Not Found. $(FAILED_MSG)$n))
    endif
  endif

  $(info JXX==$(FOUND_JXX))
  ifeq ($(FOUND_JXX),)
    #Try this alternate first, before showing error
    JXX=$(JAVA_HOME)/bin/javac
    $(info JXX==$(JXX))
    $(info cmdv=$(shell command -v $(JXX)))
    #If still not found, show an error
    $(if $(FOUND_JXX),,$(error The Java Compiler could not be located. $(FAILED_MSG)$n))
  endif

  ifeq ($(FOUND_JAR),)
    #Try this alternate first, before showing error
    JAR=$(JAVA_HOME)/bin/jar
    #If still not found, show an error
    $(if $(FOUND_JAR),,$(error The Java Jar program could not be located. $(FAILED_MSG)$n))
  endif
endif

# Export variables so they will be accessible to recursive calls to make
export JAVA_HOME JDK_INCLUDE JDK_BIN JXX JAR
REPLACE_WITH_HOME=$(subst $(JAVA_HOME),$$(JAVA_HOME),$1)

############# Save Configuration ##################################################
# Run some tests and save some settings.
javaconfig:
	$(info Writing Java Auto-Config File: $(JAVA_CONFIG_FILE))
	$(if $(FOUND_JAVA_HOME),     $(file >  $(JAVA_CONFIG_FILE),JAVA_HOME   = $(JAVA_HOME)))
	$(if $(FOUND_JDK_INCLUDE),   $(file >> $(JAVA_CONFIG_FILE),JDK_INCLUDE = $(call REPLACE_WITH_HOME,$(JDK_INCLUDE))))
	$(if $(FOUND_JDK_BIN),       $(file >> $(JAVA_CONFIG_FILE),JDK_BIN     = $(call REPLACE_WITH_HOME,$(JDK_BIN))))
	$(if $(FOUND_JXX),           $(file >> $(JAVA_CONFIG_FILE),JXX         = $(call REPLACE_WITH_HOME,$(JXX))))
	$(if $(FOUND_JAR),           $(file >> $(JAVA_CONFIG_FILE),JAR         = $(call REPLACE_WITH_HOME,$(JAR))))

	$(info JAVA_HOME   = "$(JAVA_HOME)")
	$(info JDK_INCLUDE = "$(JDK_INCLUDE)")
	$(info JDK_BIN     = "$(JDK_BIN)")
	$(info JXX         = "$(JXX)")
	$(info JAR         = "$(JAR)")

	$(info Makefile Java Auto-Config Complete)

java-config.make:  # List this include-file here so that make doesn't complain if it is not found.

#Clear the default goal if it was set to one of the targets in this file. (It should be set in the Makefile itself.)
ifeq ($(.DEFAULT_GOAL),javaconfig)
   .DEFAULT_GOAL=
endif

##############################################################################
############# About JNI_INCLUDE_FLAGS ##############################################
##############################################################################
#    The JNI_INCLUDE_FLAGS variable contains library-include flags (e.g. -I...) 
# for JDK folders that contain required linking headers for compiling c++ code that 
# interfaces with Java applications via Java Native Interface (JNI).
#
# NOTE: The Java Development Kit (JDK) is required!
#      The Java runtime (JRE) is not sufficient.
#
#    The directories that are included must sometimes be specified manually to 
# coincide with the location where Java native headers are installed. For best results, 
# it is recommended that you base the flags on the JDK_INCLUDE variable.
# This approach is easier to maintain between different machines due to the fact 
# that the location of the JDK can vary, even between machines with the same OS.
#    When looking for these directories on your system, you can search for the files
# "jni.h" and "jni_md.h". On linux and windows, these are usually found
# in two separate folders, but both are subdirectories of the JDK folder.
##############################################################################
##################### EXAMPLE: Microsoft WINDOWS #############################
#  On WINDOWS, the JDK is usually installed in:
#          "C:\Program Files\Java\jdk1.x.x_x"   (1.x.x_x is the java version)
#  If the 32-bit version of java is installed on a 64-bit Windows OS, 
#    it would be in "C:\Program Files (x86)\Java\jdk1.x.x_x"
#  You should set the JDK_INCLUDE variable to the 'include' subfolder under the 
#  JDK folder. I.e. JDK_INCLUDE='C:\Program Files (x86)\Java\jdk1.x.x_x\include'
#  Then the required files "jni.h" and "jni_md.h" can be found in
#      $(JDK_INCLUDE)   and    $(JDK_INCLUDE)\win32    respectively.
#  The JNI_INCLUDE_FLAGS would then be simply:
#      -I"${JDK_INCLUDE}" -I"${JDK_INCLUDE}"/win32 
#     The above "Windows-style" path format ("C:\...") is required for typical 
#  Windows-centric compilers (e.g. Intel, Visual Studio). However when using 
#  a POSIX-aware g++ variabt (e.g. MinGW etc) it may be necessary to specify the 
#  paths in POSIX format: "/c/Program Files/Java/jdk1.x.x_x/include" (or /cygdrive/c/... etc)
#  *** Importantly, quotes are required if the JDK path contains spaces.
#  However, this can be avoided by creating the following **highly-recommended**
#  symlinks to the "Program Files" folder:
#      "C:\Program Files"        ==>  C:\bin64   (or name it Apps64, Programs64, Progs etc.)
#      "C:\Program Files (x86)"  ==>  C:\bin32   
#  This can be done (as an administrator) with the command:  
#       mklink /D C:\bin64 "C:\Program Files"
#  Then JDK_INCLUDE becomes e.g.  C:\bin64\Java\jdk1.x.x_x\include  which does 
#  not require quotes. Alternatively you can refer to these folders using 
#  their DOS 8-character abbreviations: C:\Progra~1 and C:\Progra~2
#  C:\Progra~1 = "C:\Program Files" and C:\Progra~2 = "C:\Program Files (x86)"
##############################################################################
##################### EXAMPLE: Linux #########################################
#  The path to the JDK folder differs between versions of linux, but
# the required subdirectories are usually the same. For example:
#    Fedora Linux:   JDK_INCLUDE=/usr/java/jdk1.x.x_x/include
#    Ubuntu Linux:   JDK_INCLUDE=/usr/lib/jvm/java-x-sun-1.x.x.x/include
# But on both Fedora and Ubuntu, the directories that must be included are:
#    JNI_INCLUDE_FLAGS= -I$(JDK_INCLUDE) -I$(JDK_INCLUDE)/linux
##############################################################################
##################### EXAMPLE: Mac OSX #######################################
#    For modern versions of Java, the include path setup on Mac OSX is 
#  usually similar to:
#  	JDK_INCLUDE=/Library/Java/JavaVirtualMachines/jdk1.x.x_x.jdk/Contents/Home/include
#  	JNI_INCLUDE_FLAGS=-I$(JDK_INCLUDE) -I$(JDK_INCLUDE)/darwin
#  The folder can be found, for example using a command such as:
#     find /Library/Java/JavaVirtualMachines -name jni.h 
#            or perhaps 
#     find /System/Library/Frameworks -name jni.h
#  These commands will print one line for each JDK version found. You only
#  need to use the most recent version, and ONLY the *directory* part
#  (NOT the full path to jni.h).
#  Also, please note that this setup may differ between versions of OSX 
#  and/or versions of Java. For example with Java 1.6 there used to be just 
#  one folder to include:
#     JNI_INCLUDE_FLAGS=-I/System/Library/Frameworks/JavaVM.framework/Headers
##############################################################################
# !!! Note that the example paths given above are only meant to be a general
#  guide to the path forms on different systems. The actual paths on any given
#  system may differ from these !!!
##############################################################################

##############################################################################
# Define generic targets for cxx files (used in java bindings to the native RNA library)
# First add a rule for cxx files with corresponding header files.
# If no header is found, the second rule will apply.
##############################################################################
# $(SWIG_OUT)/%.o: %.cxx %.h
# 	$(MAKE_OUTDIR)
# 	${COMPILE_JNI} $<

# ##Use this rule if there is no associated header file
# %.o: %.cxx  
# 	$(MAKE_OUTDIR)
# 	${COMPILE_JNI} $<
